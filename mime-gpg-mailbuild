#!/usr/bin/perl -w

# Sat Dec  6 18:56:25 CET 2008
(my $email='christian-novo%jaeger,mine,nu')=~ tr/%,/@./;

use strict;

our $key_id= undef;
# undef means, it will expect a default key to be configured in your
# .gnupg/gpg.conf


my ($mydir, $myname);
BEGIN {
    use Chj::xrealpath;
    $0= xrealpath $0;
    $0=~ /(.*?)([^\/]+)\z/s or die "?";
    ($mydir, $myname)=($1,$2);
}

sub usage {
    print STDERR map{"$_\n"} @_ if @_;
    print "$myname headers body.txt [ outfile ]

  create mime message from given headers and body, optionally signing
  the body in pgp/mime format.  It completes the headers with
  return-path, from, and message-id headers if those are not present
  in the given headers file.

  If no outfile is given, prints to stdout.

  Kind-of replaces send_as_mail.
  NOTE: header handling might not be unicode or even latin1 ready yet.

  Options:
  -s | --sign   clearsign the given text in pgp/mime format.


  (See also: send_as_mail, mime-parser, (mime-worddecoder),
  Chj::Mail::SimpleHead, .. -- actually using Chj::Mail::SimpleHead here)

  (Christian Jaeger <$email>)
";
exit (@_ ? 1 : 0);
}

use Getopt::Long;
our $verbose=0;
our $opt_sign;
GetOptions("verbose"=> \$verbose,
	   "help"=> sub{usage},
	   "sign"=>\$opt_sign,
	   ) or exit 1;
usage unless @ARGV==2 or @ARGV==3;

our ($headersfile,$bodyfile,$maybe_outfile)=@ARGV;


# ---- head data ----------------

use Chj::Mail::SimpleHead;
use Chj::xopen ':all';

our $m= xopen_read $headersfile;
our $headers=Chj::Mail::SimpleHead->new_from_fh ($m);
{
    my $rest= $m->xcontent;
    (!defined $rest)
      or $rest=~ /^\s*\z/s
	or die "rest of '$headersfile' is supposed to be empty, but isn't: '$rest'";
}

use Chj::Mail::Return_path;
our $return_path=
  ($headers->decodedheader("return-path")
   or
   Return_path($headers->decodedheader("from")));

use Chj::Mail::Create_messageid;
our $messageid=
  ($headers->decodedheader("message-id") #hm or would we want to override it?
   or
   Create_messageid ($return_path));

use Chj::Mailfrom qw(mailfrom);
our $from=
  ($headers->decodedheader("from")
   or
   mailfrom);


# ---- read body and combine with head ----------

our $bfh= xopen_read $bodyfile;

use MIME::Entity;

our $entity= MIME::Entity->build
  (
   (
    map {
	defined (my $value= $headers->decodedheader ($_))
	  or die "??";#well, multiheader cases maybe?.
	($_, $value)
    }
    grep {
	($_ ne "return-path"
	 and
	 $_ ne "message-id"
	 and
	 $_ ne "from"
	)
    }
    sort keys %{$headers->headersHash} #yep sort order plays a role
   ),
   'Return-path'=> $return_path,
   'Message-id'=> $messageid,
   'From'=> $from,
   #Data     => [ "Hiho, a nice encrypted mail" ],
   Data=> $bfh->xcontent, #ok? why array?.
   Encoding => "quoted-printable",
   Charset  => "iso-8859-1",###?todo.
  );


if ($opt_sign) {

    # ---- sign ----------------------
    use lib "$mydir/lib";# my hacked version of Mail::GnuPG
    use CHJ::Mail::GnuPG;
    our $mg = CHJ::Mail::GnuPG->new (key=> $key_id);

    our $returncode = $mg->mime_sign($entity); # destructive
    $returncode == 0
      or die "$mg got error:\n".join("",@{$$mg{last_message}})."\n ";
}

our $out= do {
    if ($maybe_outfile) {
	xopen_write $maybe_outfile
    } else {
	bless *STDOUT{IO},"Chj::IO::File"
    }
};
$out->xprint($entity->as_string);
$out->xclose;

#use Chj::ruse;
#use Chj::Backtrace;
#use Chj::repl; repl;
